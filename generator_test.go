package main

import (
	plugin_go "github.com/golang/protobuf/protoc-gen-go/plugin"
	. "github.com/icza/gox/gox"
	"github.com/stretchr/testify/assert"
	"google.golang.org/protobuf/types/descriptorpb"
	"strings"
	"testing"
)

var syntax = "proto3"

func createCodeGeneratorRequest(file *descriptorpb.FileDescriptorProto) plugin_go.CodeGeneratorRequest {
	if file == nil {
		return plugin_go.CodeGeneratorRequest{
			ProtoFile: []*descriptorpb.FileDescriptorProto{
				{Syntax: &syntax},
			},
		}
	}
	file.Syntax = &syntax
	return plugin_go.CodeGeneratorRequest{
		ProtoFile: []*descriptorpb.FileDescriptorProto{
			file,
		},
	}
}

var fileHeader = `/* tslint:disable */

// This file has been generated by https://github.com/h2oai/protoc-gen-twirp_ts.
// Do not edit.`

func getContent(t *testing.T, res *plugin_go.CodeGeneratorResponse) string {
	fileContent := *res.File[1].Content
	if !strings.HasPrefix(fileContent, fileHeader) {
		t.Fatal("Generated file does not start with expected header")
	}
	return fileContent[len(fileHeader):]
}

func TestGenerate(t *testing.T) {
	tNumber := descriptorpb.FieldDescriptorProto_TYPE_DOUBLE
	tString := descriptorpb.FieldDescriptorProto_TYPE_SFIXED64
	tBool := descriptorpb.FieldDescriptorProto_TYPE_BOOL

	for _, tc := range []struct {
		name string
		req  plugin_go.CodeGeneratorRequest
		want string
	}{{
		name: "An empty input",
		req:  createCodeGeneratorRequest(nil),
		want: "",
	}, {
		name: "An enum",
		req: createCodeGeneratorRequest(&descriptorpb.FileDescriptorProto{
			EnumType: []*descriptorpb.EnumDescriptorProto{
				{Name: NewString("Foo"), Value: []*descriptorpb.EnumValueDescriptorProto{{Name: NewString("bar")}}},
			}}),
		want: `
export enum Foo {
  bar = 'bar'
}`,
	}, {
		name: "A message",
		req: createCodeGeneratorRequest(&descriptorpb.FileDescriptorProto{
			MessageType: []*descriptorpb.DescriptorProto{
				{Name: NewString("Foo"), Field: []*descriptorpb.FieldDescriptorProto{
					{Name: NewString("foo"), Type: &tNumber},
					{Name: NewString("bar"), Type: &tString},
					{Name: NewString("baz"), Type: &tBool}}},
			}}),
		want: `
export interface Foo {
  foo: number;
  bar: string;
  baz: boolean;
}`,
	}, {
		name: "A service",
		req: createCodeGeneratorRequest(&descriptorpb.FileDescriptorProto{
			Service: []*descriptorpb.ServiceDescriptorProto{{
				Name: NewString("FooService"),
				Method: []*descriptorpb.MethodDescriptorProto{{
					Name:       NewString("FooMethod"),
					InputType:  NewString("FooInput"),
					OutputType: NewString("FooOutput"),
				}},
			}},
		}),
		want: `
export interface FooService {
  fooMethod: (data: FooInput, headers?: object) => Promise<FooOutput>
}
`,
	}} {
		t.Run(tc.name, func(t *testing.T) {
			// clear the `packageFiles` before each test
			packageFiles = map[string]*packageFile{}
			ret, err := generate(&tc.req)
			if err != nil {
				t.Fatal("Error in generation", err)
			}
			fileContent := getContent(t, ret)
			// ignore leading and trailing whitespace with TrimSpace
			assert.Contains(t, strings.TrimSpace(fileContent), strings.TrimSpace(tc.want))
		})
	}
}
